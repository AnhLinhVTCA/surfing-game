{"version":3,"sources":["utils/createScreen.js","utils/coordUtil.js","utils/createParallax.js","system/BgRenderSystem.js","GameOverScreen.js","GameScreen.js","createWorld.js","system/PlayerPositionSystem.js","system/ObstacleSpawnSystem.js","system/ObstacleCollideSystem.js","system/RewardRenderSystem.js","system/RewardCollideSystem.js","system/WaveRenderSystem.js","system/ObstacleRenderSystem.js","system/RewardSpawnSystem.js","system/PlayerRenderSystem.js","system/ScoreRenderSystem.js","StartScreen.js","index.js"],"names":["noop","createScreen","update","destroy","checkPointInsideRect","point","verts","DEVICE_PIXEL_RATIO","x","y","minX","maxX","minY","maxY","createParallax","tex","width","height","startX","startY","speedX","gapX","texWidth","texHeight","regionHeight","regionWidth","animateX","delta","draw","batch","offsetX","createBgRenderSystem","parallaxGroup","backGround","init","waterY","assets","atlas","psAtlas","bgSky","findRegion","bgWater","cl1","cl2","cl3","cl4","islandTex","lightHouseTex","waterYN","water","cloud1","cloud2","cloud3","cloud4","island","lightHouse","parallaxes","add","parallax","push","addAll","ps","p","createParallaxGroup","worldState","camera","setPosition","setProjection","combined","begin","setColor","end","createRenderGameOverScreen","Game","goToStartScreen","a","createRenderChoosingScreen","setCurrentScreen","gl","canvas","pixelRatio","createBatch","createOrthoCamera","inputHandler","InputHandler","goAtlas","bonusAtlas","bg","button","title","BG_HEIGHT","BG_WIDTH","BUTTON_WIDTH","BUTTON_HEIGHT","BUTTON_RECT","TITTLE_HEIGHT","TITTLE_WIDTH","addEventListener","gender","cleanup","createRenderPlayScreen","game","whiteTex","GAP","rewardCount","goingUpTime","win","gameOver","stateTime","playerState","speedY","jumping","obstacles","rewards","gap","lastObstacleX","lastRewardX","obstacleInfos","widths","heights","speedXs","rewardInfos","playerInfo","fallingSpeed","jumpingSpeed","jumpingDecelerator","inWaterSpeedX","onAirSpeedX","world","extra","systems","passiveSystems","addSystem","system","passive","runPassive","createWorld","isTouched","generateObstacles","endX","stopSpawnBird","Math","random","type","i","length","splice","obstacle","createObstacleSpawnSystem","pL","pR","pT","pB","oL","oR","oT","oB","rewardText","reward2","texTure","reward","hit","createRenderRewardSystem","rL","rR","rT","rB","waveAnimation","WAVE_WIDTH","WAVE_HEIGHT","waveAssets","waveAtlas","findRegions","createAnimation","getKeyFrame","PlayMode","LOOP","createWaveRenderSystem","rock1Tex","rock2Tex","seaStarTex","birdAnimation","octopusAnimation","crabAnimation","BIRD_WIDTH","OCTOPUS_WIDTH","CRAB_WIDTH","STAR_WIDTH","ROCK1_WIDTH","ROCK2_WIDTH","BIRD_HEIGHT","OCTOPUS_HEIGHT","CRAB_HEIGHT","STAR_HEIGHT","ROCK1_HEIGHT","ROCK2_HEIGHT","bird","octopus","crab","LOOP_PINGPONG","createObstacleRenderSystem","generateRewards","floor","popUpScreen","createRewardSpawnSystem","asset","playerAnimation","bubbleAnimation","charJump","PLAYER_WIDTH","PLAYER_HEIGHT","BUBBLE_WIDTH","BUBBLE_HEIGHT","PLAYER_JUMP_HEIGHT","bubble","createPlayerRenderSystem","s0","s1","s2","s3","s4","s5","gift","scoreWidth","scoreHeight","GIFT_WIDTH","GIFT_HEIGHT","X_WIDTH","X_HEIGHT","scoreAtlas","score","GIFT_X","GIFT_Y","currentScore","createScoreRenderSystem","goToGameOverScreen","goToPlayScreen","csAtlas","window","choiceChar","TITLE_WIDTH","TITLE_HEIGHT","female_inactive","FI_HEIGHT","FI_WIDTH","female","F_HEIGHT","F_WIDTH","male_inactive","MI_HEIGHT","MI_WIDTH","male","M_HEIGHT","M_WIDTH","MALE_RECT","FEMALE_RECT","femaleActive","document","getElementById","info","devicePixelRatio","resizeCanvas","getContext","createWhiteTex","screen","currentScreen","loadTexture","loadingScreen","L_WIDTH","L_HEIGHT","count","fillRect","ratio","doAndCount","promise","then","result","Promise","all","loadAtlas","choosingScreenAtlas","playScreenAtlas","clearColor","clear","COLOR_BUFFER_BIT","loop","createGameLoop","setInterval","innerHTML","getFps"],"mappings":"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","file":"static/js/main.4417dd52.chunk.js","sourcesContent":["const noop = () => {};\n\nconst createScreen = ({ update = noop, destroy = noop }) => {\n  return { update, destroy };\n};\n\nexport default createScreen;\n","export const checkPointInsideRect = (point, verts, DEVICE_PIXEL_RATIO = 1) => {\n  const x = point.x * DEVICE_PIXEL_RATIO;\n  const y = point.y * DEVICE_PIXEL_RATIO;\n  // const minX = Math.min(verts[0], verts[2], verts[4], verts[6]);\n  // const maxX = Math.max(verts[0], verts[2], verts[4], verts[6]);\n  // const minY = Math.min(verts[1], verts[3], verts[5], verts[7]);\n  // const maxY = Math.max(verts[1], verts[3], verts[5], verts[7]);\n\n  const minX = verts[0];\n  const maxX = verts[0] + verts[2];\n  const minY = verts[1];\n  const maxY = verts[1] + verts[3];\n  if (x < minX || x > maxX || y < minY || y > maxY) return false;\n  return true;\n};\n","import loadTexture from 'gdxjs/lib/loadTexture';\n\nconst createParallax = (\n  tex,\n  width,\n  height,\n  startX,\n  startY,\n  speedX,\n  gapX = 0\n) => {\n  const texWidth = tex.width;\n  const texHeight = tex.height;\n  const regionHeight = height;\n  const regionWidth = (regionHeight / texHeight) * texWidth;\n  let animateX = 0;\n\n  return {\n    update(delta) {\n      animateX -= speedX * delta;\n      while (animateX <= -(regionWidth + gapX)) {\n        animateX += regionWidth + gapX;\n      }\n    },\n    draw(batch) {\n      let offsetX = animateX;\n      while (offsetX < width) {\n        // batch.draw(tex, startX + offsetX, startY, regionWidth, regionHeight);\n        tex.draw(batch, startX + offsetX, startY, regionWidth, regionHeight);\n        offsetX += regionWidth + gapX;\n      }\n    }\n  };\n};\n\nexport const loadParallax = async (\n  gl,\n  url,\n  width,\n  height,\n  startX,\n  startY,\n  speedX\n) => {\n  const tex = await loadTexture(gl, url);\n  return createParallax(tex, width, height, startX, startY, speedX);\n};\n\nexport const createParallaxGroup = () => {\n  const parallaxes = [];\n\n  return {\n    add: parallax => parallaxes.push(parallax),\n    addAll: (...ps) => {\n      for (let p of ps) {\n        parallaxes.push(p);\n      }\n    },\n    update(delta) {\n      for (let parallax of parallaxes) {\n        parallax.update(delta);\n      }\n    },\n    draw(batch) {\n      for (let parallax of parallaxes) {\n        parallax.draw(batch);\n      }\n    }\n  };\n};\n\nexport default createParallax;\n","import createParallax, { createParallaxGroup } from '../utils/createParallax';\n// import { fillRect } from 'gdxjs';\n\nexport const createBgRenderSystem = () => {\n  let parallaxGroup;\n  let backGround;\n  return {\n    init({ waterY }, { assets, width, height }) {\n      const atlas = assets.psAtlas;\n      const bgSky = atlas.findRegion('parallax_BG_sky', -1);\n      const bgWater = atlas.findRegion('parallax_BG_water', -1);\n      const cl1 = atlas.findRegion('parallax_BG_cloud1', -1);\n      const cl2 = atlas.findRegion('parallax_BG_cloud2', -1);\n      const cl3 = atlas.findRegion('parallax_BG_cloud3', -1);\n      const cl4 = atlas.findRegion('parallax_BG_cloud4', -1);\n      const islandTex = atlas.findRegion('parallax_BG_hondao', -1);\n      const lightHouseTex = atlas.findRegion('parallax_BG_ngon_hai_dang', -1);\n      backGround = bgSky;\n\n      let waterYN = waterY + height / 200 - height / 20;\n      // const bg = createParallax(bgSky, width, height, 0, 0, 0);\n      const water = createParallax(bgWater, width, height, -width / 10, waterY - height / 20, 0);\n      const cloud1 = createParallax(cl1, width, height / 16, 0, waterYN - height / 16, width / 10, width * 1.5);\n      const cloud2 = createParallax(cl2, width, height / 11, 0, waterYN - height / 11, width / 8, width * 1.5);\n      const cloud3 = createParallax(cl3, width, height / 8, 0, waterYN - height / 8, width / 6, width * 1.5);\n      const cloud4 = createParallax(cl4, width, height / 6, 0, waterYN - height / 6, width / 4, width * 1.5);\n      const island = createParallax(\n        islandTex,\n        width,\n        height / 30,\n        0,\n        waterYN - height / 30 + height / 200,\n        width / 4,\n        width\n      );\n      const lightHouse = createParallax(\n        lightHouseTex,\n        width,\n        height / 20,\n        width,\n        waterYN - height / 20,\n        width / 4,\n        width * 5\n      );\n      parallaxGroup = createParallaxGroup();\n      // parallaxGroup.add(bg);\n      parallaxGroup.add(water);\n      parallaxGroup.add(cloud1);\n      parallaxGroup.add(cloud2);\n      parallaxGroup.add(cloud3);\n      parallaxGroup.add(cloud4);\n      parallaxGroup.add(island);\n      parallaxGroup.add(lightHouse);\n    },\n    update(delta, worldState, { batch, width, height, camera, assets }) {\n      camera.setPosition(0, 0);\n      batch.setProjection(camera.combined);\n      batch.begin();\n      batch.setColor(1, 1, 1, 1);\n      backGround.draw(batch, 0, 0, width, height);\n      parallaxGroup.update(delta);\n      parallaxGroup.draw(batch);\n      batch.end();\n    }\n  };\n};\n","import { createBatch, createOrthoCamera, InputHandler } from 'gdxjs';\nimport { createRenderChoosingScreen } from './StartScreen';\nimport { checkPointInsideRect } from './utils/coordUtil';\n\nexport const createRenderGameOverScreen = (Game) => {\n  const goToStartScreen = async () => Game.setCurrentScreen(await createRenderChoosingScreen(Game));\n\n  const { gl, width, height, canvas, assets, pixelRatio } = Game;\n\n  const batch = createBatch(gl);\n  const camera = createOrthoCamera(width, height, width, height);\n  const inputHandler = new InputHandler(canvas);\n\n  const atlas = assets.goAtlas;\n  const bonusAtlas = assets.bonusAtlas;\n  const bg = bonusAtlas.findRegion('end_screen_bg', -1);\n  const button = atlas.findRegion('reload', -1);\n  const title = bonusAtlas.findRegion('game_over', -1);\n\n  const BG_HEIGHT = height;\n  const BG_WIDTH = (BG_HEIGHT * bg.width) / bg.height;\n\n  const BUTTON_WIDTH = width / 3;\n  const BUTTON_HEIGHT = (BUTTON_WIDTH * button.height) / button.width;\n  const BUTTON_RECT = [width / 2 - BUTTON_WIDTH / 2, (height * 2.9) / 4, BUTTON_WIDTH, BUTTON_HEIGHT];\n\n  const TITTLE_HEIGHT = height / 2.5;\n  const TITTLE_WIDTH = (TITTLE_HEIGHT * title.width) / title.height;\n\n  let point = {};\n  inputHandler.addEventListener('touchStart', (x, y) => {\n    point = { x: x, y: y };\n    if (checkPointInsideRect(point, BUTTON_RECT, pixelRatio)) {\n      goToStartScreen();\n      Game.gender = 1;\n    }\n  });\n\n  const update = (delta) => {\n    camera.setPosition(0, 0);\n    batch.setProjection(camera.combined);\n    batch.begin();\n    batch.setColor(1, 1, 1, 1);\n    bg.draw(batch, width / 2 - BG_WIDTH / 2, height / 2 - BG_HEIGHT / 2, BG_WIDTH, BG_HEIGHT);\n\n    button.draw(batch, width / 2 - BUTTON_WIDTH / 2, (height * 2.9) / 4, BUTTON_WIDTH, BUTTON_HEIGHT);\n\n    title.draw(batch, width / 2 - TITTLE_WIDTH / 2, (height * 1.2) / 5, TITTLE_WIDTH, TITTLE_HEIGHT);\n\n    batch.end();\n  };\n\n  return {\n    update,\n    destroy() {\n      inputHandler.cleanup();\n    }\n  };\n};\n","import { InputHandler } from \"gdxjs\";\nimport createWorld from \"./createWorld\";\nimport { createPlayerPositionSystem } from \"./system/PlayerPositionSystem\";\nimport { createPlayerRenderSystem } from \"./system/PlayerRenderSystem\";\n// import { createWaterLineRenderSystem } from './system/WaterLineRenderSystem';\nimport { createObstacleSpawnSystem } from \"./system/ObstacleSpawnSystem\";\nimport { createObstacleRenderSystem } from \"./system/ObstacleRenderSystem\";\nimport { createObstacleCollideSystem } from \"./system/ObstacleCollideSystem\";\nimport { createRenderRewardSystem } from \"./system/RewardRenderSystem\";\nimport { createRewardSpawnSystem } from \"./system/RewardSpawnSystem\";\nimport { createRewardCollideSystem } from \"./system/RewardCollideSystem\";\nimport { createBgRenderSystem } from \"./system/BgRenderSystem\";\nimport { createWaveRenderSystem } from \"./system/WaveRenderSystem\";\nimport { createRenderGameOverScreen } from \"./GameOverScreen\";\nimport { createScoreRenderSystem } from \"./system/ScoreRenderSystem\";\n\nconst createRenderPlayScreen = (game) => {\n  const {\n    gender,\n    canvas,\n    pixelRatio,\n    width,\n    height,\n    gl,\n    batch,\n    camera,\n    whiteTex,\n    assets,\n  } = game;\n\n  const inputHandler = new InputHandler(canvas);\n\n  const GAP = width / 6;\n  const PLAYER_INITIAL_Y = (2 * height) / 3;\n\n  const worldState = {\n    rewardCount: 0,\n    goingUpTime: 0,\n    win: false,\n    gameOver: false,\n    gender,\n    stateTime: 0,\n    playerState: {\n      x: GAP,\n      y: PLAYER_INITIAL_Y,\n      speedX: 0,\n      speedY: 0,\n      width: width / 8,\n      height: width / 7,\n      jumping: false,\n      stateTime: 0,\n    },\n    waterY: height / 2.1 + height / 20,\n    obstacles: [],\n    rewards: [],\n    gap: GAP,\n    lastObstacleX: 2 * width,\n    lastRewardX: 2 * width,\n    obstacleInfos: {\n      // [bird, rock1, rock2, seaStar]\n      widths: [width / 9, width / 3, width / 3.5, width / 9],\n      heights: [height / 20, height / 4, height / 4, width / 9],\n      speedXs: [-width / 3, 0, 0, 0],\n    },\n    rewardInfos: {\n      width: width / 9,\n      height: width / 9,\n    },\n    playerInfo: {\n      fallingSpeed: height / 3,\n      jumpingSpeed: -height * 1.2,\n      jumpingDecelerator: height * 2,\n      inWaterSpeedX: width / 2,\n      onAirSpeedX: width,\n    },\n  };\n  const extra = {\n    canvas,\n    pixelRatio,\n    width,\n    height,\n    gl,\n    batch,\n    camera,\n    whiteTex,\n    inputHandler,\n    assets,\n  };\n  const world = createWorld(worldState, extra);\n  world.addSystem(createPlayerPositionSystem(), true);\n  world.addSystem(createObstacleSpawnSystem(), true);\n  world.addSystem(createObstacleCollideSystem(), true);\n  world.addSystem(createRenderRewardSystem(), true);\n  world.addSystem(createRewardCollideSystem(), true);\n\n  world.addSystem(createBgRenderSystem());\n  world.addSystem(createWaveRenderSystem());\n  // world.addSystem(createWaterLineRenderSystem());\n  world.addSystem(createObstacleRenderSystem());\n  world.addSystem(createRewardSpawnSystem());\n  world.addSystem(createPlayerRenderSystem());\n  world.addSystem(createScoreRenderSystem());\n\n  const goToGameOverScreen = async () =>\n    game.setCurrentScreen(await createRenderGameOverScreen(game));\n\n  // const goToRewardScreen = async () => {\n  //   game.setCurrentScreen(await createRenderRewardScreen(game));\n  // };\n\n  let delayStateTime = 0;\n  const update = (delta) => {\n    if (worldState.rewardCount === 5) {\n      delayStateTime += delta;\n      world.update(delta);\n      if (delayStateTime >= 0.5) {\n        // goToRewardScreen();\n      }\n    } else {\n      if (!worldState.gameOver) {\n        worldState.stateTime += delta;\n        world.update(delta);\n      } else {\n        // world.update(delta, false);\n        goToGameOverScreen();\n      }\n    }\n  };\n\n  return {\n    update,\n    destroy() {\n      inputHandler.cleanup();\n    },\n  };\n};\n\nexport default createRenderPlayScreen;\n","export default (worldState, extra) => {\n  const systems = [];\n  const passiveSystems = [];\n  return {\n    addSystem(system, passive = false) {\n      system.init && system.init(worldState, extra);\n      if (passive) {\n        passiveSystems.push(system);\n      } else {\n        systems.push(system);\n      }\n    },\n    update(delta, runPassive = true) {\n      for (let system of systems) {\n        system.update(delta, worldState, extra);\n      }\n      if (runPassive) {\n        for (let system of passiveSystems) {\n          system.update(delta, worldState, extra);\n        }\n      }\n    }\n  };\n};\n","export const createPlayerPositionSystem = inputhandler => {\n  return {\n    update(delta, worldState, extra) {\n      const { inputHandler, height } = extra;\n      const {\n        playerState,\n        waterY,\n        playerInfo: {\n          fallingSpeed,\n          jumpingSpeed,\n          jumpingDecelerator,\n          inWaterSpeedX,\n          onAirSpeedX\n        }\n      } = worldState;\n\n      if (playerState.jumping) {\n        playerState.speedY += jumpingDecelerator * delta;\n        playerState.speedX = onAirSpeedX;\n        if (playerState.y + playerState.height > waterY * 1.1) {\n          playerState.jumping = false;\n        }\n      } else {\n        playerState.speedX = inWaterSpeedX;\n        if (inputHandler.isTouched()) {\n          worldState.goingUpTime = worldState.stateTime + 0.15;\n        }\n        if (worldState.goingUpTime >= worldState.stateTime) {\n          playerState.speedY = -fallingSpeed;\n        } else {\n          playerState.speedY = fallingSpeed / 2;\n        }\n        if (playerState.y + playerState.height < waterY * 0.9) {\n          playerState.jumping = true;\n          playerState.speedY = jumpingSpeed;\n        }\n      }\n\n      playerState.x += playerState.speedX * delta;\n      playerState.y += playerState.speedY * delta;\n\n      if (playerState.y > height - playerState.height - height / 10) {\n        playerState.y = height - playerState.height - height / 10;\n      }\n    }\n  };\n};\n","export const createObstacleSpawnSystem = () => {\n  const generateObstacles = (\n    obstacles,\n    startX,\n    endX,\n    height,\n    obstacleInfos,\n    stopSpawnBird\n  ) => {\n    if (Math.random() > 0.4) {\n      // bird\n      obstacles.push({\n        x: (endX + startX) / 2,\n        y: Math.random() * (height / 3 - height / 8) + height / 8,\n        type: 0,\n        speedX: obstacleInfos.speedXs[0],\n        stateTime: 0\n      });\n    }\n    if (Math.random() > 0.5) {\n      // rock1\n      obstacles.push({\n        x: (endX + startX) / 2,\n        y: height - obstacleInfos.heights[1],\n        type: 1,\n        speedX: obstacleInfos.speedXs[1],\n        stateTime: 0\n      });\n    } else {\n      // rock2\n      obstacles.push({\n        x: (endX + startX) / 2,\n        y: height - obstacleInfos.heights[2],\n        type: 2,\n        speedX: obstacleInfos.speedXs[2],\n        stateTime: 0\n      });\n    }\n\n    if (Math.random() > 0.3) {\n      // sea star\n      obstacles.push({\n        x: endX,\n        y: (height * 2.6) / 4,\n        speedX: obstacleInfos.speedXs[3],\n        type: 3\n      });\n    }\n  };\n  return {\n    update(delta, worldState, { width, height }) {\n      let {\n        playerState: { x },\n        obstacles,\n        gap,\n        lastObstacleX,\n        obstacleInfos\n      } = worldState;\n\n      while (lastObstacleX - x < width * 2) {\n        generateObstacles(\n          obstacles,\n          lastObstacleX + width * 2,\n          lastObstacleX + width * 4,\n          height,\n          obstacleInfos,\n          worldState.stopSpawnBird\n        );\n        lastObstacleX = worldState.lastObstacleX = lastObstacleX + width * 2;\n      }\n\n      for (let i = obstacles.length - 1; i >= 0; i--) {\n        let { type, x } = obstacles[i];\n        if (obstacles[i].x + worldState.obstacleInfos.widths[type] < x - gap) {\n          obstacles.splice(i, 1);\n        }\n      }\n\n      for (let obstacle of obstacles) {\n        obstacle.x += obstacle.speedX * delta;\n      }\n    }\n  };\n};\n","export const createObstacleCollideSystem = () => {\n  return {\n    update(delta, worldState) {\n      const { playerState, obstacles, obstacleInfos } = worldState;\n      if (obstacles.length > 0) {\n        // console.log(obstacleInfos, obstacles);\n        const { widths, heights } = obstacleInfos;\n        const pL = playerState.x;\n        const pR = playerState.x + playerState.width;\n        const pT = playerState.y;\n        const pB = playerState.y + playerState.height;\n        for (let i = obstacles.length - 1; i >= 0; i--) {\n          const { x, y, type } = obstacles[i];\n          const oL = x;\n          const oR = x + widths[type];\n          const oT = y;\n          const oB = y + heights[type];\n          // console.log(pL, pR, pT, pB, oL, oR, oT, oB);\n          if (pL < oR && pR > oL && pT < oB && pB > oT) {\n            worldState.gameOver = true;\n          }\n        }\n      }\n    }\n  };\n};\n","// import { fillRect } from 'gdxjs';\n\nexport const createRenderRewardSystem = () => {\n  let rewardText = 0;\n  return {\n    init(worldState, { assets, width, height }) {\n      const atlas = assets.psAtlas;\n      const reward2 = atlas.findRegion('hop_qua2', -1);\n      rewardText = {\n        texTure: reward2,\n        width: width / 6,\n        height: ((width / 6) * reward2.height) / reward2.width\n      };\n    },\n    update(\n      delta,\n      { rewards, playerState: { x }, gap },\n      { batch, width, height, camera, whiteTex }\n    ) {\n      camera.setPosition(x - gap, 0);\n      batch.setProjection(camera.combined);\n      batch.begin();\n      batch.setColor(1, 1, 1, 1);\n      for (let reward of rewards) {\n        if (!reward.hit) {\n          // fillRect(\n          //   batch,\n          //   whiteTex,\n          //   reward.x,\n          //   reward.y,\n          //   reward.width,\n          //   reward.height\n          // );\n          rewardText.texTure.draw(\n            batch,\n            reward.x + reward.width / 2 - rewardText.width / 2,\n            reward.y + reward.height / 2 - rewardText.height / 2,\n            rewardText.width,\n            rewardText.height\n          );\n        }\n      }\n      batch.end();\n    }\n  };\n};\n","export const createRewardCollideSystem = () => {\n  return {\n    update(delta, worldState) {\n      const { playerState, rewards, rewardInfos } = worldState;\n      if (rewards.length > 0) {\n        // console.log(obstacleInfos, obstacles);\n        const pL = playerState.x;\n        const pR = playerState.x + playerState.width;\n        const pT = playerState.y;\n        const pB = playerState.y + playerState.height;\n        for (let i = rewards.length - 1; i >= 0; i--) {\n          if (rewards[i].hit) {\n            continue;\n          }\n          const rL = rewards[i].x;\n          const rR = rewards[i].x + rewardInfos.width;\n          const rT = rewards[i].y;\n          const rB = rewards[i].y + rewardInfos.height;\n\n          if (pL < rR && pR > rL && pT < rB && pB > rT) {\n            rewards[i].hit = true;\n            worldState.rewardCount += 1;\n          }\n        }\n      }\n    }\n  };\n};\n","import { createAnimation } from 'gdxjs';\nimport { PlayMode } from 'gdxjs/lib/createAnimation';\n\nexport const createWaveRenderSystem = () => {\n  let WAVE_WIDTH = 0;\n  let WAVE_HEIGHT = 0;\n  let stateTime = 0;\n  let waveAnimation;\n  return {\n    init({ waterY }, { width, height, assets }) {\n      const atlas = assets.waveAtlas;\n      const waveAssets = atlas.findRegions('final wave');\n      waveAnimation = createAnimation(0.1, waveAssets);\n      WAVE_WIDTH = width;\n      WAVE_HEIGHT = (waveAssets[0].height * WAVE_WIDTH) / waveAssets[0].width;\n      if (waterY + WAVE_HEIGHT - height / 20 < height) {\n        // console.log('low');\n        WAVE_HEIGHT = height - (waterY - height / 20);\n      }\n    },\n    update(delta, { waterY }, { batch, width, height, camera }) {\n      stateTime += delta;\n      camera.setPosition(0, 0);\n      batch.setProjection(camera.combined);\n      batch.begin();\n      waveAnimation\n        .getKeyFrame(stateTime, PlayMode.LOOP)\n        .draw(batch, 0, waterY - height / 20, WAVE_WIDTH, WAVE_HEIGHT);\n      batch.end();\n    }\n  };\n};\n","import { createAnimation } from 'gdxjs';\nimport { PlayMode } from 'gdxjs/lib/createAnimation';\nexport const createObstacleRenderSystem = () => {\n  let rock1Tex;\n  let rock2Tex;\n  let seaStarTex;\n  let birdAnimation;\n  let octopusAnimation;\n  let crabAnimation;\n  let BIRD_WIDTH,\n    OCTOPUS_WIDTH,\n    CRAB_WIDTH,\n    STAR_WIDTH,\n    ROCK1_WIDTH,\n    ROCK2_WIDTH;\n  let BIRD_HEIGHT,\n    OCTOPUS_HEIGHT,\n    CRAB_HEIGHT,\n    STAR_HEIGHT,\n    ROCK1_HEIGHT,\n    ROCK2_HEIGHT;\n\n  return {\n    init({ obstacleInfos }, { assets, width, height }) {\n      const atlas = assets.psAtlas;\n      rock1Tex = atlas.findRegion('cuc_da', 1);\n      rock2Tex = atlas.findRegion('cuc_da', 2);\n      seaStarTex = atlas.findRegion('sao_bien', -1);\n      const bird = atlas.findRegions('chim');\n      const octopus = atlas.findRegions('bachtuoc');\n      const crab = atlas.findRegions('cua');\n      birdAnimation = createAnimation(0.15, bird);\n      octopusAnimation = createAnimation(0.15, octopus);\n      crabAnimation = createAnimation(0.15, crab);\n\n      BIRD_WIDTH = width / 5;\n      BIRD_HEIGHT = (bird[0].height * BIRD_WIDTH) / bird[0].width;\n      ROCK1_HEIGHT = height / 3;\n      ROCK1_WIDTH = (ROCK1_HEIGHT * rock1Tex.width) / rock1Tex.height;\n      ROCK2_HEIGHT = height / 3;\n      ROCK2_WIDTH = (ROCK2_HEIGHT * rock2Tex.width) / rock2Tex.height;\n      OCTOPUS_HEIGHT = height / 6;\n      OCTOPUS_WIDTH = (octopus[0].width * OCTOPUS_HEIGHT) / octopus[0].height;\n      CRAB_HEIGHT = height / 11;\n      CRAB_WIDTH = (crab[0].width * CRAB_HEIGHT) / crab[0].height;\n      STAR_HEIGHT = height / 12;\n      STAR_WIDTH = (STAR_HEIGHT * seaStarTex.width) / seaStarTex.height;\n    },\n    update(\n      delta,\n      {\n        obstacles,\n        playerState: { x },\n        gap,\n        obstacleInfos: { widths, heights }\n      },\n      { batch, camera, whiteTex, assets, width, height }\n    ) {\n      camera.setPosition(x - gap, 0);\n      batch.setProjection(camera.combined);\n      batch.begin();\n      for (let obstacle of obstacles) {\n        const { type, x, y } = obstacle;\n        // fillRect(batch, whiteTex, x, y, widths[type], heights[type]);\n        if (type === 0) {\n          obstacle.stateTime += delta;\n          birdAnimation\n            .getKeyFrame(obstacle.stateTime, PlayMode.LOOP_PINGPONG)\n            .draw(\n              batch,\n              x + widths[type] / 2 - BIRD_WIDTH / 2,\n              y + heights[type] / 2 - BIRD_HEIGHT / 2,\n              BIRD_WIDTH,\n              BIRD_HEIGHT\n            );\n        }\n        if (type === 1) {\n          obstacle.stateTime += delta;\n          rock1Tex.draw(\n            batch,\n            x + widths[type] / 2 - ROCK1_WIDTH / 2 - width / 16,\n            y + heights[type] - ROCK1_HEIGHT + height / 80,\n            ROCK1_WIDTH,\n            ROCK1_HEIGHT\n          );\n          crabAnimation\n            .getKeyFrame(obstacle.stateTime, PlayMode.LOOP_PINGPONG)\n            .draw(\n              batch,\n              x - CRAB_WIDTH / 2 + width / 20,\n              y - CRAB_HEIGHT / 2 + height / 20,\n              CRAB_WIDTH,\n              CRAB_HEIGHT\n            );\n          seaStarTex.draw(\n            batch,\n            x + ROCK1_WIDTH / 5,\n            y + ROCK1_HEIGHT / 2.7,\n            STAR_WIDTH,\n            STAR_HEIGHT\n          );\n        }\n        if (type === 2) {\n          obstacle.stateTime += delta;\n          rock2Tex.draw(\n            batch,\n            x + widths[type] / 2 - ROCK2_WIDTH / 2 + width / 16,\n            y + heights[type] - ROCK2_HEIGHT + height / 60,\n            ROCK2_WIDTH,\n            ROCK2_HEIGHT\n          );\n          octopusAnimation\n            .getKeyFrame(obstacle.stateTime, PlayMode.LOOP_PINGPONG)\n            .draw(\n              batch,\n              x - OCTOPUS_WIDTH / 2 + width / 20,\n              y - OCTOPUS_WIDTH / 2,\n              OCTOPUS_WIDTH,\n              OCTOPUS_HEIGHT\n            );\n        }\n        if (type === 3) {\n          seaStarTex.draw(\n            batch,\n            x + widths[type] / 2 - STAR_WIDTH / 2,\n            y + heights[type] / 2 - STAR_HEIGHT / 2,\n            STAR_WIDTH,\n            STAR_HEIGHT\n          );\n        }\n      }\n      batch.end();\n    }\n  };\n};\n","export const createRewardSpawnSystem = () => {\n  const generateRewards = (\n    rewards,\n    startX,\n    endX,\n    height,\n    width,\n    rewardInfos,\n    worldState\n  ) => {\n    if (Math.random() > 0.6) {\n      rewards.push({\n        x: endX,\n        y: height / 4,\n        width: rewardInfos.width, // hit box size\n        height: rewardInfos.width, // hit box size\n        hit: false,\n        type: Math.floor(Math.random() * 3),\n        popUpScreen: false\n      });\n    } else {\n      if (Math.random() > 0.9) {\n        rewards.push({\n          x: endX,\n          y: (height * 6.6) / 8,\n          width: rewardInfos.width, // hit box size\n          height: rewardInfos.width, // hit box size\n          hit: false,\n          type: Math.floor(Math.random() * 3),\n          popUpScreen: false\n        });\n      }\n    }\n  };\n  return {\n    update(delta, worldState, { width, height }) {\n      let {\n        playerState: { x },\n        rewards,\n        lastRewardX,\n        rewardInfos\n      } = worldState;\n\n      while (lastRewardX - x < width * 2) {\n        generateRewards(\n          rewards,\n          lastRewardX + width * 2,\n          lastRewardX + width * 4,\n          height,\n          width,\n          rewardInfos,\n          worldState\n        );\n        lastRewardX = worldState.lastRewardX = lastRewardX + width * 2;\n      }\n      // for (let i = rewards.length - 1; i >= 0; i--) {\n      //   if (rewards[i].x + worldState.obstacleInfos.width < x - gap) {\n      //     rewards.splice(i, 1);\n      //   }\n      // }\n    }\n  };\n};\n","// import { fillRect } from 'gdxjs';\nimport { createAnimation } from 'gdxjs';\nimport { PlayMode } from 'gdxjs/lib/createAnimation';\n// import {}\n\nexport const createPlayerRenderSystem = () => {\n  let PLAYER_WIDTH = 0;\n  let PLAYER_HEIGHT = 0;\n  let BUBBLE_WIDTH = 0;\n  let BUBBLE_HEIGHT = 0;\n  let PLAYER_JUMP_HEIGHT = 0;\n  let asset;\n  let atlas;\n  let playerAnimation;\n  let bubbleAnimation;\n  let charJump;\n  return {\n    init({ gender, playerState }, { assets, width, height }) {\n      atlas = assets.psAtlas;\n      if (gender === 0) {\n        asset = atlas.findRegions('male');\n        charJump = atlas.findRegion('male_jump', -1);\n      } else {\n        asset = atlas.findRegions('female');\n        charJump = atlas.findRegion('female_jump', -1);\n      }\n      const bubble = atlas.findRegions('bubble');\n\n      bubbleAnimation = createAnimation(0.2, bubble);\n      playerAnimation = createAnimation(0.3, asset);\n      PLAYER_WIDTH = width / 3.2;\n      PLAYER_HEIGHT = (asset[0].height * PLAYER_WIDTH) / asset[0].width;\n      PLAYER_JUMP_HEIGHT = (charJump.height * PLAYER_WIDTH) / charJump.width;\n\n      BUBBLE_WIDTH = width / 6;\n      BUBBLE_HEIGHT = (bubble[0].height * BUBBLE_WIDTH) / bubble[0].width;\n    },\n    update(delta, { playerState, gap }, { batch, camera, whiteTex, width }) {\n      camera.setPosition(playerState.x - gap, 0);\n      batch.setProjection(camera.combined);\n      batch.begin();\n      // fillRect(\n      //   batch,\n      //   whiteTex,\n      //   playerState.x,\n      //   playerState.y,\n      //   playerState.width,\n      //   playerState.height\n      // );\n      playerState.stateTime += delta;\n      if (playerState.jumping) {\n        charJump.draw(\n          batch,\n          playerState.x + playerState.width / 2 - PLAYER_WIDTH / 2,\n          playerState.y + playerState.height / 2 - PLAYER_JUMP_HEIGHT / 2,\n          PLAYER_WIDTH,\n          PLAYER_JUMP_HEIGHT\n        );\n      } else {\n        playerAnimation\n          .getKeyFrame(playerState.stateTime, PlayMode.LOOP_PINGPONG)\n          .draw(\n            batch,\n            playerState.x + playerState.width / 2 - PLAYER_WIDTH / 2,\n            playerState.y + playerState.height / 2 - PLAYER_HEIGHT / 2,\n            PLAYER_WIDTH,\n            PLAYER_HEIGHT\n          );\n      }\n      bubbleAnimation\n        .getKeyFrame(playerState.stateTime, PlayMode.LOOP_PINGPONG)\n        .draw(\n          batch,\n          playerState.x - PLAYER_WIDTH / 2,\n          playerState.y + playerState.height,\n          BUBBLE_WIDTH,\n          BUBBLE_HEIGHT,\n          BUBBLE_WIDTH / 2,\n          BUBBLE_HEIGHT / 2,\n          0,\n          1,\n          1\n        );\n      batch.end();\n    }\n  };\n};\n","export const createScoreRenderSystem = () => {\n  let scoreWidth = [];\n  let scoreHeight = 0;\n  let GIFT_WIDTH = 0;\n  let GIFT_HEIGHT = 0;\n  let X_WIDTH = 0;\n  let X_HEIGHT = 0;\n  let s0, s1, s2, s3, s4, s5, gift, x;\n\n  return {\n    init(worldState, { assets, width, height }) {\n      const scoreAtlas = assets.score;\n      s0 = scoreAtlas.findRegion('0_score', -1);\n      s1 = scoreAtlas.findRegion('1_score', -1);\n      s2 = scoreAtlas.findRegion('2_score', -1);\n      s3 = scoreAtlas.findRegion('3_score', -1);\n      s4 = scoreAtlas.findRegion('4_score', -1);\n      s5 = scoreAtlas.findRegion('5_score', -1);\n      scoreHeight = height / 26;\n      scoreWidth = [\n        (scoreHeight * s0.width) / s0.height,\n        (scoreHeight * s1.width) / s1.height,\n        (scoreHeight * s2.width) / s2.height,\n        (scoreHeight * s3.width) / s3.height,\n        (scoreHeight * s4.width) / s4.height,\n        (scoreHeight * s5.width) / s5.height\n      ];\n      gift = scoreAtlas.findRegion('hopqua_score', -1);\n      x = scoreAtlas.findRegion('x_score', -1);\n\n      GIFT_HEIGHT = height / 16;\n      GIFT_WIDTH = (GIFT_HEIGHT * gift.width) / gift.height;\n\n      X_HEIGHT = height / 45;\n      X_WIDTH = (X_HEIGHT * x.width) / x.height;\n    },\n    update(delta, worldState, { batch, camera, width, height }) {\n      const GIFT_X = width / 16;\n      const GIFT_Y = height / 50;\n      camera.setPosition(0, 0);\n      batch.setProjection(camera.combined);\n      batch.begin();\n      gift.draw(batch, GIFT_X, GIFT_Y, GIFT_WIDTH, GIFT_HEIGHT);\n      x.draw(\n        batch,\n        GIFT_X + (GIFT_WIDTH * 3.5) / 5,\n        GIFT_Y + (GIFT_HEIGHT * 3.5) / 5,\n        X_WIDTH,\n        X_HEIGHT\n      );\n\n      let currentScore = 0;\n      if (worldState.rewardCount === 0) currentScore = s0;\n      if (worldState.rewardCount === 1) currentScore = s1;\n      if (worldState.rewardCount === 2) currentScore = s2;\n      if (worldState.rewardCount === 3) currentScore = s3;\n      if (worldState.rewardCount === 4) currentScore = s4;\n      if (worldState.rewardCount === 5) currentScore = s5;\n\n      currentScore.draw(\n        batch,\n        GIFT_X + GIFT_WIDTH * 1.2,\n        GIFT_Y + GIFT_HEIGHT - scoreHeight,\n        scoreWidth[worldState.rewardCount],\n        scoreHeight\n      );\n\n      batch.end();\n    }\n  };\n};\n","import createScreen from './utils/createScreen';\nimport { InputHandler } from 'gdxjs';\nimport { checkPointInsideRect } from './utils/coordUtil';\n// import createWhiteTexture from 'gl-white-texture';\nimport createRenderPlayScreen from './GameScreen';\n\nexport const createRenderChoosingScreen = (Game) => {\n  const goToPlayScreen = async () => Game.setCurrentScreen(await createRenderPlayScreen(Game));\n\n  const { width, height, assets, canvas, pixelRatio, batch, camera } = Game;\n\n  const inputHandler = new InputHandler(canvas);\n  // const whiteTex = createWhiteTexture(gl);\n  const atlas = assets.csAtlas;\n\n  window.atlas = atlas;\n\n  const bg = atlas.findRegion('bg', -1);\n\n  const BG_HEIGHT = height;\n  const BG_WIDTH = (BG_HEIGHT * bg.width) / bg.height;\n\n  const button = atlas.findRegion('btn_play', -1);\n  const BUTTON_WIDTH = width / 4;\n  const BUTTON_HEIGHT = (BUTTON_WIDTH * button.height) / button.width;\n\n  const choiceChar = atlas.findRegion('select_character', -1);\n  const TITLE_WIDTH = (width * 2.81) / 4;\n  const TITLE_HEIGHT = (TITLE_WIDTH * choiceChar.height) / choiceChar.width;\n\n  const female_inactive = atlas.findRegion('fmale__inactive', -1);\n  const FI_HEIGHT = height / 3.6;\n  const FI_WIDTH = (FI_HEIGHT * female_inactive.width) / female_inactive.height;\n\n  const female = atlas.findRegion('fmale', -1);\n  const F_HEIGHT = height / 2.8;\n  const F_WIDTH = (F_HEIGHT * female.width) / female.height;\n\n  const male_inactive = atlas.findRegion('male_inactive', -1);\n  const MI_HEIGHT = height / 3.6;\n  const MI_WIDTH = (MI_HEIGHT * male_inactive.width) / male_inactive.height;\n\n  const male = atlas.findRegion('male', -1);\n  const M_HEIGHT = height / 2.8;\n  const M_WIDTH = (M_HEIGHT * male.width) / male.height;\n\n  const MALE_RECT = [width / 1.9 + width / 20, (height * 4.8) / 6 - MI_HEIGHT, MI_WIDTH, MI_HEIGHT];\n\n  const FEMALE_RECT = [width / 1.9 - FI_WIDTH - width / 20, (height * 4.8) / 6 - MI_HEIGHT, FI_WIDTH, FI_HEIGHT];\n\n  const BUTTON_RECT = [width / 2 - BUTTON_WIDTH / 2, (height * 6.2) / 7, BUTTON_WIDTH, BUTTON_HEIGHT];\n\n  let femaleActive = true;\n  let point;\n  inputHandler.addEventListener('touchStart', (x, y) => {\n    point = { x: x, y: y };\n    if (checkPointInsideRect(point, MALE_RECT, pixelRatio)) {\n      femaleActive = false;\n      Game.gender = 0;\n    }\n    if (checkPointInsideRect(point, FEMALE_RECT, pixelRatio)) {\n      femaleActive = true;\n      Game.gender = 1;\n    }\n  });\n\n  inputHandler.addEventListener('touchStart', (x, y) => {\n    if (checkPointInsideRect(point, BUTTON_RECT, pixelRatio)) {\n      goToPlayScreen();\n    }\n  });\n\n  return createScreen({\n    update(delta) {\n      camera.setPosition(0, 0);\n      batch.setProjection(camera.combined);\n      batch.begin();\n      // background\n      bg.draw(batch, width / 2 - BG_WIDTH / 2, height / 2 - BG_HEIGHT / 2, BG_WIDTH, BG_HEIGHT);\n      // play button\n      button.draw(batch, width / 2 - BUTTON_WIDTH / 2, (height * 6.2) / 7, BUTTON_WIDTH, BUTTON_HEIGHT);\n      // choice char\n      choiceChar.draw(batch, width / 2 - TITLE_WIDTH / 2, (height * 5.75) / 7, TITLE_WIDTH, TITLE_HEIGHT);\n      // draw char\n      if (femaleActive) {\n        female.draw(batch, width / 1.9 - F_WIDTH, (height * 4.8) / 6 - F_HEIGHT, F_WIDTH, F_HEIGHT);\n        male_inactive.draw(batch, width / 1.9 + width / 20, (height * 4.8) / 6 - MI_HEIGHT, MI_WIDTH, MI_HEIGHT);\n      } else {\n        male.draw(batch, width / 1.9, (height * 4.8) / 6 - M_HEIGHT, M_WIDTH, M_HEIGHT);\n        female_inactive.draw(\n          batch,\n          width / 1.9 - FI_WIDTH - width / 20,\n          (height * 4.8) / 6 - MI_HEIGHT,\n          FI_WIDTH,\n          FI_HEIGHT\n        );\n      }\n      batch.end();\n    },\n    destroy() {\n      inputHandler.cleanup();\n    }\n  });\n};\n","import \"./index.css\";\nimport {\n  resizeCanvas,\n  createGameLoop,\n  createBatch,\n  createOrthoCamera,\n  loadTexture,\n  loadAtlas,\n  fillRect,\n} from \"gdxjs\";\nimport createWhiteTex from \"gl-white-texture\";\nimport { createRenderChoosingScreen } from \"./StartScreen\";\n\nconst init = async () => {\n  const canvas = document.getElementById(\"main\");\n  const info = document.getElementById(\"info\");\n  const pixelRatio = window.devicePixelRatio || 1;\n  const [width, height] = resizeCanvas(canvas, pixelRatio);\n  const gl = canvas.getContext(\"webgl\");\n\n  const batch = createBatch(gl);\n  const camera = createOrthoCamera(width, height, width, height);\n  const whiteTex = createWhiteTex(gl);\n\n  const Game = {\n    gender: 1,\n    width,\n    height,\n    canvas,\n    gl,\n    batch,\n    camera,\n    whiteTex,\n    pixelRatio: pixelRatio,\n    setCurrentScreen(screen) {\n      if (Game.currentScreen) {\n        Game.currentScreen.destroy();\n      }\n      Game.currentScreen = screen;\n    },\n  };\n\n  const loadingScreen = await loadTexture(gl, \"./assets/loading.jpg\");\n  const L_HEIGHT = height;\n  const L_WIDTH = (L_HEIGHT * loadingScreen.width) / loadingScreen.height;\n  let count = 0;\n\n  const draw = () => {\n    camera.setPosition(0, 0);\n    batch.setProjection(camera.combined);\n    batch.begin();\n    batch.setColor(1, 1, 1, 1);\n    fillRect(\n      batch,\n      loadingScreen,\n      width / 2 - L_WIDTH / 2,\n      0,\n      L_WIDTH,\n      L_HEIGHT\n    );\n    fillRect(\n      batch,\n      whiteTex,\n      width / 2 - width / (1.45 * 2),\n      (height * 2.5) / 4 - height / 50,\n      width / 1.45,\n      height / 25\n    );\n    batch.setColor(0, 0, 0, 1);\n    fillRect(\n      batch,\n      whiteTex,\n      width / 2 - width / 3,\n      (height * 2.5) / 4 - height / 60,\n      width / 1.5,\n      height / 30\n    );\n    batch.setColor(1, 1, 1, 1);\n    let ratio = count / 6;\n    fillRect(\n      batch,\n      whiteTex,\n      width / 2 - width / (1.55 * 2),\n      (height * 2.5) / 4 - height / 80,\n      (width / 1.55) * ratio,\n      height / 40\n    );\n    batch.end();\n  };\n\n  const doAndCount = (promise) =>\n    promise.then((result) => {\n      draw();\n      count++;\n      return result;\n    });\n\n  const [\n    choosingScreenAtlas,\n    playScreenAtlas,\n    waveAtlas,\n    gameOver,\n    score,\n    bonusAtlas,\n  ] = await Promise.all([\n    doAndCount(loadAtlas(gl, \"./assets/surf.atlas\")),\n    doAndCount(loadAtlas(gl, \"./assets/asset_wave.atlas\")),\n    doAndCount(loadAtlas(gl, \"./assets/wave.atlas\")),\n    doAndCount(loadAtlas(gl, \"./assets/end_surfing.atlas\")),\n    doAndCount(loadAtlas(gl, \"./assets/score.atlas\")),\n    doAndCount(loadAtlas(gl, \"./assets/final_asset.atlas\")),\n  ]);\n\n  let assets = {\n    csAtlas: choosingScreenAtlas,\n    psAtlas: playScreenAtlas,\n    waveAtlas: waveAtlas,\n    goAtlas: gameOver,\n    score: score,\n    bonusAtlas: bonusAtlas,\n  };\n\n  Game.assets = assets;\n\n  Game.setCurrentScreen(await createRenderChoosingScreen(Game));\n\n  gl.clearColor(1, 0.388, 0.012, 1);\n  const update = (delta) => {\n    gl.clear(gl.COLOR_BUFFER_BIT);\n    if (Game.currentScreen) {\n      Game.currentScreen.update(delta);\n    }\n  };\n\n  const loop = createGameLoop(update);\n  setInterval(() => (info.innerHTML = `FPS: ${loop.getFps()}`), 500);\n};\n\ninit();\n"],"sourceRoot":""}